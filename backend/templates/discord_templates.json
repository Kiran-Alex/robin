{"templates": [{"category": "moderation", "name": "moderation_system", "description": "Comprehensive moderation system with kick, ban, warn, mute, unmute, and log viewing commands, permission checks, logging to data.json, and error handling", "code": "import discord\nimport json\nfrom discord.ext import commands\nfrom discord import utils, Color\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.NoPrivateMessage):\n        await ctx.send('This command cannot be used in private messages.')\n    elif isinstance(error, commands.DisabledCommand):\n        await ctx.send('Sorry. This command is disabled and cannot be used.')\n    elif isinstance(error, commands.CheckFailure):\n        await ctx.send('You do not have permission to run this command.')\n    elif isinstance(error, commands.MissingRequiredArgument):\n        await ctx.send(str(error))\n    elif isinstance(error, commands.BadArgument):\n        await ctx.send(str(error))\n    else:\n        raise error\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'warnings': {}, 'logs': []}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.command()\n@commands.has_permissions(kick_members=True)\n@commands.guild_only()\nasync def kick(ctx, member: discord.Member, *, reason='No reason provided'):\n    try:\n        await member.kick(reason=reason)\n        await ctx.send(f'Kicked {member.mention} for: {reason}')\n        data = await load_data()\n        data['logs'].append({'action': 'kick', 'user': member.id, 'moderator': ctx.author.id, 'reason': reason, 'timestamp': str(discord.utils.utcnow())})\n        await save_data(data)\n    except discord.Forbidden:\n        await ctx.send('I lack permission to kick this user.')\n    except Exception as e:\n        await ctx.send(f'Error: {str(e)}')\n\n@bot.command()\n@commands.has_permissions(ban_members=True)\n@commands.guild_only()\nasync def ban(ctx, member: discord.Member, *, reason='No reason provided'):\n    try:\n        await member.ban(reason=reason)\n        await ctx.send(f'Banned {member.mention} for: {reason}')\n        data = await load_data()\n        data['logs'].append({'action': 'ban', 'user': member.id, 'moderator': ctx.author.id, 'reason': reason, 'timestamp': str(discord.utils.utcnow())})\n        await save_data(data)\n    except discord.Forbidden:\n        await ctx.send('I lack permission to ban this user.')\n    except Exception as e:\n        await ctx.send(f'Error: {str(e)}')\n\n@bot.command()\n@commands.has_permissions(manage_messages=True)\n@commands.guild_only()\nasync def warn(ctx, member: discord.Member, *, reason='No reason provided'):\n    try:\n        await ctx.send(f'Warned {member.mention} for: {reason}')\n        data = await load_data()\n        user_id = str(member.id)\n        data['warnings'].setdefault(user_id, []).append({'reason': reason, 'moderator': ctx.author.id, 'timestamp': str(discord.utils.utcnow())})\n        data['logs'].append({'action': 'warn', 'user': member.id, 'moderator': ctx.author.id, 'reason': reason, 'timestamp': str(discord.utils.utcnow())})\n        await save_data(data)\n    except Exception as e:\n        await ctx.send(f'Error: {str(e)}')\n\n@bot.command()\n@commands.has_permissions(manage_roles=True)\n@commands.guild_only()\nasync def mute(ctx, member: discord.Member, *, reason='No reason provided'):\n    try:\n        mute_role = utils.get(ctx.guild.roles, name='Muted')\n        if not mute_role:\n            mute_role = await ctx.guild.create_role(name='Muted', colour=Color.greyple())\n            for channel in ctx.guild.channels:\n                await channel.set_permissions(mute_role, speak=False, send_messages=False, read_message_history=True, read_messages=True)\n        await member.add_roles(mute_role, reason=reason)\n        await ctx.send(f'Muted {member.mention} for: {reason}')\n        data = await load_data()\n        data['logs'].append({'action': 'mute', 'user': member.id, 'moderator': ctx.author.id, 'reason': reason, 'timestamp': str(discord.utils.utcnow())})\n        await save_data(data)\n    except discord.Forbidden:\n        await ctx.send('I lack permission to manage roles.')\n    except Exception as e:\n        await ctx.send(f'Error: {str(e)}')\n\n@bot.command()\n@commands.has_permissions(manage_roles=True)\n@commands.guild_only()\nasync def unmute(ctx, member: discord.Member):\n    try:\n        mute_role = utils.get(ctx.guild.roles, name='Muted')\n        if mute_role:\n            await member.remove_roles(mute_role)\n            await ctx.send(f'Unmuted {member.mention}')\n            data = await load_data()\n            data['logs'].append({'action': 'unmute', 'user': member.id, 'moderator': ctx.author.id, 'reason': 'No reason provided', 'timestamp': str(discord.utils.utcnow())})\n            await save_data(data)\n        else:\n            await ctx.send('Muted role not found.')\n    except discord.Forbidden:\n        await ctx.send('I lack permission to manage roles.')\n    except Exception as e:\n        await ctx.send(f'Error: {str(e)}')\n\n@bot.command()\n@commands.has_permissions(view_audit_log=True)\nasync def logs(ctx, limit: int = 10):\n    data = await load_data()\n    logs = data['logs'][-limit:]\n    embed = discord.Embed(title='Moderation Logs', color=Color.blue())\n    for log in logs:\n        user = await bot.fetch_user(log['user'])\n        moderator = await bot.fetch_user(log['moderator'])\n        embed.add_field(name=f\"Action: {log['action']}\", value=f\"User: {user.name if user else 'Unknown'}\nModerator: {moderator.name if moderator else 'Unknown'}\nReason: {log['reason']}\nTime: {log['timestamp']}\", inline=False)\n    await ctx.send(embed=embed)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["moderation", "permissions", "kick", "ban", "warn", "mute", "unmute", "logs", "json"], "dependencies": ["discord.py"]}, {"category": "economy", "name": "economy_system", "description": "Full economy system with balance checking, giving coins, daily rewards, work command, shop, buy items, and persistence using data.json", "code": "import discord\nimport json\nfrom discord.ext import commands\nimport random\nimport datetime\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.NoPrivateMessage):\n        await ctx.send('This command cannot be used in private messages.')\n    elif isinstance(error, commands.DisabledCommand):\n        await ctx.send('Sorry. This command is disabled and cannot be used.')\n    elif isinstance(error, commands.CheckFailure):\n        await ctx.send('You do not have permission to run this command.')\n    elif isinstance(error, commands.MissingRequiredArgument):\n        await ctx.send(str(error))\n    elif isinstance(error, commands.BadArgument):\n        await ctx.send(str(error))\n    else:\n        raise error\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'economy': {}, 'last_daily': {}, 'inventory': {}, 'shop': {'item1': 100, 'item2': 200}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.command()\nasync def balance(ctx, member: discord.Member = None):\n    member = member or ctx.author\n    data = await load_data()\n    user_id = str(member.id)\n    balance = data['economy'].get(user_id, 0)\n    await ctx.send(f'{member.mention} has {balance} coins.')\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def give(ctx, member: discord.Member, amount: int):\n    if amount <= 0:\n        return await ctx.send('Amount must be positive.')\n    data = await load_data()\n    user_id = str(member.id)\n    data['economy'][user_id] = data['economy'].get(user_id, 0) + amount\n    await save_data(data)\n    await ctx.send(f'Gave {amount} coins to {member.mention}.')\n\n@bot.command()\nasync def daily(ctx):\n    data = await load_data()\n    user_id = str(ctx.author.id)\n    last_daily = data['last_daily'].get(user_id)\n    if last_daily:\n        last_time = datetime.datetime.fromisoformat(last_daily)\n        if (discord.utils.utcnow() - last_time).days < 1:\n            return await ctx.send('You have already claimed your daily reward today.')\n    reward = random.randint(100, 500)\n    data['economy'][user_id] = data['economy'].get(user_id, 0) + reward\n    data['last_daily'][user_id] = discord.utils.utcnow().isoformat()\n    await save_data(data)\n    await ctx.send(f'You claimed {reward} coins as your daily reward!')\n\n@bot.command()\nasync def work(ctx):\n    data = await load_data()\n    user_id = str(ctx.author.id)\n    earnings = random.randint(50, 200)\n    data['economy'][user_id] = data['economy'].get(user_id, 0) + earnings\n    await save_data(data)\n    await ctx.send(f'You worked and earned {earnings} coins!')\n\n@bot.command()\nasync def shop(ctx):\n    data = await load_data()\n    embed = discord.Embed(title='Shop', color=discord.Color.gold())\n    for item, price in data['shop'].items():\n        embed.add_field(name=item, value=f'Price: {price} coins', inline=False)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def buy(ctx, item: str):\n    data = await load_data()\n    user_id = str(ctx.author.id)\n    if item not in data['shop']:\n        return await ctx.send('Item not found in shop.')\n    price = data['shop'][item]\n    balance = data['economy'].get(user_id, 0)\n    if balance < price:\n        return await ctx.send('Insufficient coins.')\n    data['economy'][user_id] -= price\n    data['inventory'].setdefault(user_id, []).append(item)\n    await save_data(data)\n    await ctx.send(f'You bought {item} for {price} coins!')\n\n@bot.command()\nasync def inventory(ctx, member: discord.Member = None):\n    member = member or ctx.author\n    data = await load_data()\n    user_id = str(member.id)\n    inv = data['inventory'].get(user_id, [])\n    embed = discord.Embed(title=f'{member.name}'s Inventory', color=discord.Color.purple())\n    embed.description = ', '.join(inv) or 'Empty'\n    await ctx.send(embed=embed)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["economy", "json", "balance", "daily", "work", "shop", "buy", "inventory"], "dependencies": ["discord.py", "random", "datetime"]}, {"category": "utility", "name": "utility_system", "description": "Utility commands including ping for latency, user info, server info, avatar, and clear messages", "code": "import discord\nfrom discord.ext import commands\nimport datetime\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.NoPrivateMessage):\n        await ctx.send('This command cannot be used in private messages.')\n    elif isinstance(error, commands.DisabledCommand):\n        await ctx.send('Sorry. This command is disabled and cannot be used.')\n    elif isinstance(error, commands.CheckFailure):\n        await ctx.send('You do not have permission to run this command.')\n    elif isinstance(error, commands.MissingRequiredArgument):\n        await ctx.send(str(error))\n    elif isinstance(error, commands.BadArgument):\n        await ctx.send(str(error))\n    else:\n        raise error\n\n@bot.command()\nasync def ping(ctx):\n    latency = round(bot.latency * 1000)\n    await ctx.send(f'Pong! Latency is {latency}ms')\n\n@bot.command()\nasync def userinfo(ctx, member: discord.Member = None):\n    member = member or ctx.author\n    embed = discord.Embed(title=f'User Info - {member}', color=discord.Color.blue())\n    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)\n    embed.add_field(name='ID', value=member.id, inline=True)\n    embed.add_field(name='Nickname', value=member.nick or 'None', inline=True)\n    embed.add_field(name='Created At', value=member.created_at.strftime('%Y-%m-%d %H:%M:%S'), inline=True)\n    embed.add_field(name='Joined At', value=member.joined_at.strftime('%Y-%m-%d %H:%M:%S'), inline=True)\n    embed.add_field(name='Top Role', value=member.top_role.mention, inline=True)\n    embed.add_field(name='Bot?', value=member.bot, inline=True)\n    embed.add_field(name='Status', value=str(member.status), inline=True)\n    embed.add_field(name='Activity', value=member.activity.name if member.activity else 'None', inline=True)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def serverinfo(ctx):\n    guild = ctx.guild\n    embed = discord.Embed(title=f'Server Info - {guild.name}', color=discord.Color.green())\n    embed.set_thumbnail(url=guild.icon.url if guild.icon else None)\n    embed.add_field(name='ID', value=guild.id, inline=True)\n    embed.add_field(name='Owner', value=guild.owner.mention, inline=True)\n    embed.add_field(name='Created At', value=guild.created_at.strftime('%Y-%m-%d %H:%M:%S'), inline=True)\n    embed.add_field(name='Members', value=guild.member_count, inline=True)\n    embed.add_field(name='Channels', value=len(guild.channels), inline=True)\n    embed.add_field(name='Roles', value=len(guild.roles), inline=True)\n    embed.add_field(name='Emojis', value=len(guild.emojis), inline=True)\n    embed.add_field(name='Boost Level', value=guild.premium_tier, inline=True)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def avatar(ctx, member: discord.Member = None):\n    member = member or ctx.author\n    embed = discord.Embed(title=f'{member.name}'s Avatar', color=discord.Color.random())\n    embed.set_image(url=member.avatar.url if member.avatar else member.default_avatar.url)\n    await ctx.send(embed=embed)\n\n@bot.command()\n@commands.has_permissions(manage_messages=True)\nasync def clear(ctx, amount: int = 5):\n    if amount < 1 or amount > 100:\n        return await ctx.send('Amount must be between 1 and 100.')\n    deleted = await ctx.channel.purge(limit=amount)\n    await ctx.send(f'Deleted {len(deleted)} messages.', delete_after=5)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["utility", "ping", "userinfo", "serverinfo", "avatar", "clear"], "dependencies": ["discord.py"]}, {"category": "fun", "name": "fun_system", "description": "Fun commands including dice roll, 8ball for questions, joke teller, meme generator, and coin flip", "code": "import discord\nfrom discord.ext import commands\nimport random\nimport requests\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.NoPrivateMessage):\n        await ctx.send('This command cannot be used in private messages.')\n    elif isinstance(error, commands.DisabledCommand):\n        await ctx.send('Sorry. This command is disabled and cannot be used.')\n    elif isinstance(error, commands.CheckFailure):\n        await ctx.send('You do not have permission to run this command.')\n    elif isinstance(error, commands.MissingRequiredArgument):\n        await ctx.send(str(error))\n    elif isinstance(error, commands.BadArgument):\n        await ctx.send(str(error))\n    else:\n        raise error\n\n@bot.command()\nasync def roll(ctx, sides: int = 6):\n    if sides < 1:\n        return await ctx.send('Number of sides must be positive!')\n    result = random.randint(1, sides)\n    await ctx.send(f'{ctx.author.mention} rolled a {result} on a {sides}-sided die!')\n\n@bot.command(name='8ball')\nasync def eight_ball(ctx, *, question):\n    responses = ['It is certain.', 'It is decidedly so.', 'Without a doubt.', 'Yes - definitely.', 'You may rely on it.', 'As I see it, yes.', 'Most likely.', 'Outlook good.', 'Yes.', 'Signs point to yes.', 'Reply hazy, try again.', 'Ask again later.', 'Better not tell you now.', 'Cannot predict now.', 'Concentrate and ask again.', \"Don't count on it.\", 'My reply is no.', 'My sources say no.', 'Outlook not so good.', 'Very doubtful.']\n    await ctx.send(f'Question: {question}\\nAnswer: {random.choice(responses)}')\n\n@bot.command()\nasync def joke(ctx):\n    jokes = ['Why did the scarecrow win an award? Because he was outstanding in his field!', 'What do you call fake spaghetti? An impasta!', 'Why don\u2019t skeletons fight each other? They don\u2019t have the guts!', 'What do you call a boomerang that doesn\u2019t come back? A stick!', 'Why did the coffee file a police report? It got mugged!']\n    await ctx.send(random.choice(jokes))\n\n@bot.command()\nasync def coinflip(ctx):\n    result = random.choice(['Heads', 'Tails'])\n    await ctx.send(f'The coin landed on {result}!')\n\n@bot.command()\nasync def meme(ctx):\n    response = requests.get('https://meme-api.com/gimme')\n    if response.status_code == 200:\n        data = response.json()\n        embed = discord.Embed(title=data['title'], url=data['postLink'])\n        embed.set_image(url=data['url'])\n        embed.set_footer(text=f'Author: {data[\"author\"]} | Subreddit: {data[\"subreddit\"]}')\n        await ctx.send(embed=embed)\n    else:\n        await ctx.send('Failed to fetch a meme. Try again later.')\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["fun", "roll", "8ball", "joke", "coinflip", "meme", "random"], "dependencies": ["discord.py", "random", "requests"]}, {"category": "music", "name": "music_system", "description": "Comprehensive music system with play, pause, resume, skip, queue, and volume control, using youtube_dl for streaming", "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCopyright (c) 2019 Valentin B.\nA simple music bot written in discord.py using youtube-dl.\nThough it's a simple example, music bots are complex and require much time and knowledge until they work perfectly.\nUse this as an example or a base for your own bot and extend it as you want. If there are any bugs, please let me know.\nRequirements:\nPython 3.5+\npip install -U discord.py pynacl youtube-dl\nYou also need FFmpeg in your PATH environment variable or the FFmpeg.exe binary in your bot's directory on Windows.\n\"\"\"\nimport asyncio\nimport functools\nimport itertools\nimport math\nimport random\nimport discord\nimport youtube_dl\nfrom async_timeout import timeout\nfrom discord.ext import commands\n\n# Silence useless bug reports messages\nyoutube_dl.utils.bug_reports_message = lambda: ''\n\nclass VoiceError(Exception):\n    pass\n\nclass YTDLError(Exception):\n    pass\n\nclass YTDLSource(discord.PCMVolumeTransformer):\n    YTDL_OPTIONS = {\n        'format': 'bestaudio/best',\n        'extractaudio': True,\n        'audioformat': 'mp3',\n        'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',\n        'restrictfilenames': True,\n        'noplaylist': True,\n        'nocheckcertificate': True,\n        'ignoreerrors': False,\n        'logtostderr': False,\n        'quiet': True,\n        'no_warnings': True,\n        'default_search': 'auto',\n        'source_address': '0.0.0.0',\n    }\n\n    FFMPEG_OPTIONS = {\n        'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',\n        'options': '-vn',\n    }\n\n    ytdl = youtube_dl.YoutubeDL(YTDL_OPTIONS)\n\n    def __init__(self, ctx: commands.Context, source: discord.FFmpegPCMAudio, *, data: dict, volume: float = 0.5):\n        super().__init__(source, volume)\n        self.requester = ctx.author\n        self.channel = ctx.channel\n        self.data = data\n        self.uploader = data.get('uploader')\n        self.uploader_url = data.get('uploader_url')\n        date = data.get('upload_date')\n        self.upload_date = date[6:8] + '.' + date[4:6] + '.' + date[0:4]\n        self.title = data.get('title')\n        self.thumbnail = data.get('thumbnail')\n        self.description = data.get('description')\n        self.duration = self.parse_duration(int(data.get('duration')))\n        self.tags = data.get('tags')\n        self.url = data.get('webpage_url')\n        self.views = data.get('view_count')\n        self.likes = data.get('like_count')\n        self.dislikes = data.get('dislike_count')\n        self.stream_url = data.get('url')\n\n    def __str__(self):\n        return '**{0.title}** by **{0.uploader}**'.format(self)\n\n    @classmethod\n    async def create_source(cls, ctx: commands.Context, search: str, *, loop: asyncio.BaseEventLoop = None):\n        loop = loop or asyncio.get_event_loop()\n        partial = functools.partial(cls.ytdl.extract_info, search, download=False, process=False)\n        data = await loop.run_in_executor(None, partial)\n        if data is None:\n            raise YTDLError('Couldn\\'t find anything that matches `{}`'.format(search))\n        if 'entries' not in data:\n            process_info = data\n        else:\n            process_info = None\n            for entry in data['entries']:\n                if entry:\n                    process_info = entry\n                    break\n        if process_info is None:\n            raise YTDLError('Couldn\\'t find anything that matches `{}`'.format(search))\n        webpage_url = process_info['webpage_url']\n        partial = functools.partial(cls.ytdl.extract_info, webpage_url, download=False)\n        processed_info = await loop.run_in_executor(None, partial)\n        if processed_info is None:\n            raise YTDLError('Couldn\\'t fetch `{}`'.format(webpage_url))\n        if 'entries' not in processed_info:\n            info = processed_info\n        else:\n            info = None\n            while info is None:\n                try:\n                    info = processed_info['entries'].pop(0)\n                except IndexError:\n                    raise YTDLError('Couldn\\'t retrieve any matches for `{}`'.format(webpage_url))\n        return cls(ctx, discord.FFmpegPCMAudio(info['url'], **cls.FFMPEG_OPTIONS), data=info)\n\n    @staticmethod\n    def parse_duration(duration: int):\n        minutes, seconds = divmod(duration, 60)\n        hours, minutes = divmod(minutes, 60)\n        days, hours = divmod(hours, 24)\n        duration = []\n        if days > 0:\n            duration.append('{ } days'.format(days))\n        if hours > 0:\n            duration.append('{ } hours'.format(hours))\n        if minutes > 0:\n            duration.append('{ } minutes'.format(minutes))\n        if seconds > 0:\n            duration.append('{ } seconds'.format(seconds))\n        return ', '.join(duration)\n\nclass Song:\n    __slots__ = ('source', 'requester')\n\n    def __init__(self, source: YTDLSource):\n        self.source = source\n        self.requester = source.requester\n\n    def create_embed(self):\n        embed = (discord.Embed(title='Now playing', description='```css\\n{0.source.title}\\n```'.format(self), color=discord.Color.blurple())\n                 .add_field(name='Duration', value=self.source.duration)\n                 .add_field(name='Requested by', value=self.requester.mention)\n                 .add_field(name='Uploader', value='[{0.source.uploader}]({0.source.uploader_url})'.format(self))\n                 .add_field(name='URL', value='[Click]({0.source.url})'.format(self))\n                 .set_thumbnail(url=self.source.thumbnail))\n        return embed\n\nclass SongQueue(asyncio.Queue):\n    def __iter__(self):\n        return list(itertools.islice(self._queue, 0, self.maxsize))\n\nclass VoiceState:\n    def __init__(self, bot: commands.Bot, ctx: commands.Context):\n        self.bot = bot\n        self._ctx = ctx\n        self.current = None\n        self.voice = None\n        self.next = asyncio.Event()\n        self.songs = SongQueue(maxsize=10)\n        self._loop = False\n        self._volume = 0.5\n        self.skip_votes = set()\n        self.audio_player = bot.loop.create_task(self.audio_player_task())\n\n    def __del__(self):\n        self.audio_player.cancel()\n\n    @property\n    def loop(self):\n        return self._loop\n\n    @loop.setter\n    def loop(self, value: bool):\n        self._loop = value\n\n    @property\n    def volume(self):\n        return self._volume\n\n    @volume.setter\n    def volume(self, value: float):\n        self._volume = value\n\n    @property\n    def is_playing(self):\n        return self.voice and self.current\n\n    async def audio_player_task(self):\n        while True:\n            self.next.clear()\n            if not self.loop:\n                try:\n                    async with timeout(180):  # 3 minutes\n                        self.current = await self.songs.get()\n                except asyncio.TimeoutError:\n                    self.bot.loop.create_task(self.stop())\n                    return\n            else:\n                self.current = Song(self.current.source)\n\n            self.current.source.volume = self._volume\n            self.voice.play(self.current.source, after=self.play_next_song)\n            await self.current.source.channel.send(embed=self.current.create_embed())\n            await self.next.wait()\n\n    def play_next_song(self, error=None):\n        if error:\n            raise VoiceError(str(error))\n        self.next.set()\n\n    def skip(self):\n        self.skip_votes.clear()\n        if self.is_playing:\n            self.voice.stop()\n\n    async def stop(self):\n        self.songs.clear()\n        if self.voice:\n            await self.voice.disconnect()\n            self.voice = None\n\nclass Music(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n        self.voice_states = {}\n\n    def get_voice_state(self, ctx: commands.Context):\n        state = self.voice_states.get(ctx.guild.id)\n        if not state:\n            state = VoiceState(self.bot, ctx)\n            self.voice_states[ctx.guild.id] = state\n        return state\n\n    def cog_unload(self):\n        for state in self.voice_states.values():\n            self.bot.loop.create_task(state.stop())\n\n    def cog_check(self, ctx: commands.Context):\n        if not ctx.guild:\n            raise commands.NoPrivateMessage('This command can\\'t be used in DM channels.')\n        return True\n\n    async def cog_before_invoke(self, ctx: commands.Context):\n        ctx.voice_state = self.get_voice_state(ctx)\n\n    @commands.command(name='join', invoke_without_subcommand=True)\n    async def _join(self, ctx: commands.Context):\n        destination = ctx.author.voice.channel if ctx.author.voice else None\n        if ctx.voice_state.voice:\n            await ctx.voice_state.voice.move_to(destination)\n            return\n        ctx.voice_state.voice = await destination.connect()\n\n    @commands.command(name='summon')\n    @commands.has_permissions(manage_guild=True)\n    async def _summon(self, ctx: commands.Context, *, channel: discord.VoiceChannel = None):\n        if not channel and not ctx.author.voice:\n            raise VoiceError('You are neither connected to a voice channel nor specified a channel to join.')\n        destination = channel or ctx.author.voice.channel\n        if ctx.voice_state.voice:\n            await ctx.voice_state.voice.move_to(destination)\n            return\n        ctx.voice_state.voice = await destination.connect()\n\n    @commands.command(name='leave')\n    @commands.has_permissions(manage_guild=True)\n    async def _leave(self, ctx: commands.Context):\n        await ctx.voice_state.stop()\n        del self.voice_states[ctx.guild.id]\n\n    @commands.command(name='volume')\n    async def _volume(self, ctx: commands.Context, *, volume: int):\n        if not ctx.voice_state.is_playing:\n            return await ctx.send('Nothing being played at the moment.')\n        if 0 > volume > 100:\n            return await ctx.send('Volume must be between 0 and 100')\n        ctx.voice_state.volume = volume / 100\n        await ctx.send('Volume of the player set to {}%'.format(volume))\n\n    @commands.command(name='now', aliases=['current', 'playing'])\n    async def _now(self, ctx: commands.Context):\n        await ctx.send(embed=ctx.voice_state.current.create_embed())\n\n    @commands.command(name='pause')\n    @commands.has_permissions(manage_guild=True)\n    async def _pause(self, ctx: commands.Context):\n        if ctx.voice_state.is_playing and ctx.voice_state.voice.is_playing():\n            ctx.voice_state.voice.pause()\n            await ctx.message.add_reaction('\u23ef')\n\n    @commands.command(name='resume')\n    @commands.has_permissions(manage_guild=True)\n    async def _resume(self, ctx: commands.Context):\n        if ctx.voice_state.is_playing and ctx.voice_state.voice.is_paused():\n            ctx.voice_state.voice.resume()\n            await ctx.message.add_reaction('\u23ef')\n\n    @commands.command(name='skip')\n    async def _skip(self, ctx: commands.Context):\n        if not ctx.voice_state.is_playing:\n            return await ctx.send('Not playing any music right now...')\n        voter = ctx.message.author\n        if voter == ctx.voice_state.current.requester:\n            await ctx.message.add_reaction('\u23ed')\n            ctx.voice_state.skip()\n        elif voter.id not in ctx.voice_state.skip_votes:\n            ctx.voice_state.skip_votes.add(voter.id)\n            total_votes = len(ctx.voice_state.skip_votes)\n            if total_votes >= 3:\n                await ctx.message.add_reaction('\u23ed')\n                ctx.voice_state.skip()\n            else:\n                await ctx.send('Skip vote added, currently at **{}/3**'.format(total_votes))\n        else:\n            await ctx.send('You have already voted to skip this song.')\n\n    @commands.command(name='queue')\n    async def _queue(self, ctx: commands.Context, *, page: int = 1):\n        if len(ctx.voice_state.songs) == 0:\n            return await ctx.send('Empty queue.')\n        items_per_page = 10\n        pages = math.ceil(len(ctx.voice_state.songs) / items_per_page)\n        start = (page - 1) * items_per_page\n        end = start + items_per_page\n        queue = ''\n        for i, song in enumerate(ctx.voice_state.songs[start:end], start=start):\n            queue += '`{0}` [**{1.source.title}**]({1.source.url})\\n'.format(i + 1, song)\n        embed = (discord.Embed(description='**{} tracks:**\\n\\n{}'.format(len(ctx.voice_state.songs), queue))\n                 .set_footer(text='Viewing page {}/{}'.format(page, pages)))\n        await ctx.send(embed=embed)\n\n    @commands.command(name='shuffle')\n    async def _shuffle(self, ctx: commands.Context):\n        if len(ctx.voice_state.songs) == 0:\n            return await ctx.send('Empty queue.')\n        random.shuffle(ctx.voice_state.songs)\n        await ctx.message.add_reaction('\u2705')\n\n    @commands.command(name='remove')\n    async def _remove(self, ctx: commands.Context, index: int):\n        if len(ctx.voice_state.songs) == 0:\n            return await ctx.send('Empty queue.')\n        ctx.voice_state.songs.remove(index - 1)\n        await ctx.message.add_reaction('\u2705')\n\n    @commands.command(name='loop')\n    async def _loop(self, ctx: commands.Context):\n        if not ctx.voice_state.is_playing:\n            return await ctx.send('Nothing being played at the moment.')\n        ctx.voice_state.loop = not ctx.voice_state.loop\n        await ctx.message.add_reaction('\u2705')\n\n    @commands.command(name='play')\n    async def _play(self, ctx: commands.Context, *, search: str):\n        if not ctx.voice_state.voice:\n            await ctx.invoke(self._join)\n        try:\n            source = await YTDLSource.create_source(ctx, search, loop=self.bot.loop)\n        except YTDLError as e:\n            await ctx.send('An error occurred while processing this request: {}'.format(str(e)))\n        else:\n            song = Song(source)\n            await ctx.voice_state.songs.put(song)\n            await ctx.send('Enqueued {}'.format(str(source)))\n\n    @_join.before_invoke\n    @_play.before_invoke\n    async def ensure_voice_state(self, ctx: commands.Context):\n        if not ctx.author.voice or not ctx.author.voice.channel:\n            raise commands.CommandError('You are not connected to any voice channel.')\n        if ctx.voice_client:\n            if ctx.voice_client.channel != ctx.author.voice.channel:\n                raise commands.CommandError('Bot is already in a voice channel.')\n\nbot = commands.Bot('music.', description='Yet another music bot.')\nbot.add_cog(Music(bot))\nbot.run('YOUR_BOT_TOKEN')", "tags": ["music", "youtube_dl", "play", "pause", "resume", "skip", "queue", "volume"], "dependencies": ["discord.py", "youtube_dl", "pynacl", "async_timeout"]}, {"category": "ticket", "name": "ticket_system", "description": "Ticket system with create ticket, close ticket, and transcript logging to data.json", "code": "import discord\nimport json\nfrom discord.ext import commands\nimport datetime\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'tickets': {}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.command()\nasync def ticket_setup(ctx):\n    embed = discord.Embed(title='Support Tickets', description='React to open a ticket.', color=discord.Color.blue())\n    msg = await ctx.send(embed=embed)\n    await msg.add_reaction('\ud83c\udf9f\ufe0f')\n\n@bot.event\nasync def on_reaction_add(reaction, user):\n    if user.bot:\n        return\n    if str(reaction.emoji) == '\ud83c\udf9f\ufe0f':\n        guild = reaction.message.guild\n        category = discord.utils.get(guild.categories, name='Tickets')\n        if not category:\n            category = await guild.create_category('Tickets')\n        channel_name = f'ticket-{user.name}'\n        existing_channel = discord.utils.get(guild.text_channels, name=channel_name)\n        if existing_channel:\n            await reaction.message.channel.send('You already have an open ticket.')\n            return\n        channel = await guild.create_text_channel(channel_name, category=category)\n        await channel.set_permissions(user, read_messages=True, send_messages=True)\n        await channel.set_permissions(guild.default_role, read_messages=False)\n        embed = discord.Embed(title='New Ticket', description=f'{user.mention}, describe your issue.', color=discord.Color.green())\n        await channel.send(embed=embed)\n        data = await load_data()\n        data['tickets'][str(channel.id)] = {'user': user.id, 'created_at': str(discord.utils.utcnow())}\n        await save_data(data)\n\n@bot.command()\n@commands.has_permissions(manage_channels=True)\nasync def close(ctx):\n    if 'ticket' not in ctx.channel.name:\n        return await ctx.send('This is not a ticket channel.')\n    data = await load_data()\n    ticket_data = data['tickets'].get(str(ctx.channel.id))\n    if ticket_data:\n        user = await bot.fetch_user(ticket_data['user'])\n        transcript = await ctx.channel.history(limit=None).flatten()\n        transcript_text = '\\n'.join([f'{msg.author.name}: {msg.content}' for msg in transcript[::-1]])\n        with open(f'transcript-{ctx.channel.name}.txt', 'w') as f:\n            f.write(transcript_text)\n        await user.send(file=discord.File(f'transcript-{ctx.channel.name}.txt'))\n        await ctx.send('Ticket closed. Transcript sent.')\n        del data['tickets'][str(ctx.channel.id)]\n        await save_data(data)\n    await ctx.channel.delete()\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def add_user(ctx, member: discord.Member):\n    if 'ticket' not in ctx.channel.name:\n        return await ctx.send('This is not a ticket channel.')\n    await ctx.channel.set_permissions(member, read_messages=True, send_messages=True)\n    await ctx.send(f'Added {member.mention} to the ticket.')\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["ticket", "support", "create", "close", "transcript", "json"], "dependencies": ["discord.py"]}, {"category": "leveling", "name": "leveling_system", "description": "Leveling system with XP gain on messages, level up notifications, rank command, and persistence in data.json", "code": "import discord\nimport json\nfrom discord.ext import commands\nimport math\nimport random\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'levels': {}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.event\nasync def on_message(message):\n    if message.author.bot:\n        return\n    data = await load_data()\n    user_id = str(message.author.id)\n    data['levels'].setdefault(user_id, {'xp': 0, 'level': 0})\n    data['levels'][user_id]['xp'] += random.randint(15, 25)\n    current_level = data['levels'][user_id]['level']\n    required_xp = 5 * (current_level ** 2) + 50 * current_level + 100\n    if data['levels'][user_id]['xp'] >= required_xp:\n        data['levels'][user_id]['level'] += 1\n        data['levels'][user_id]['xp'] -= required_xp\n        await message.channel.send(f'Congratulations {message.author.mention}! You leveled up to level {data[\"levels\"][user_id][\"level\"]}!')\n    await save_data(data)\n    await bot.process_commands(message)\n\n@bot.command()\nasync def rank(ctx, member: discord.Member = None):\n    member = member or ctx.author\n    data = await load_data()\n    user_id = str(member.id)\n    if user_id not in data['levels']:\n        return await ctx.send('No level data found.')\n    level = data['levels'][user_id]['level']\n    xp = data['levels'][user_id]['xp']\n    required_xp = 5 * (level ** 2) + 50 * level + 100\n    embed = discord.Embed(title=f'{member.name}'s Rank', color=discord.Color.orange())\n    embed.add_field(name='Level', value=level, inline=True)\n    embed.add_field(name='XP', value=f'{xp}/{required_xp}', inline=True)\n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def leaderboard(ctx):\n    data = await load_data()\n    sorted_users = sorted(data['levels'].items(), key=lambda x: x[1]['level'], reverse=True)[:10]\n    embed = discord.Embed(title='Leaderboard', color=discord.Color.gold())\n    for i, (user_id, info) in enumerate(sorted_users, 1):\n        user = await bot.fetch_user(int(user_id))\n        embed.add_field(name=f'{i}. {user.name if user else \"Unknown\"}', value=f'Level: {info[\"level\"]} | XP: {info[\"xp\"]}', inline=False)\n    await ctx.send(embed=embed)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["leveling", "xp", "level_up", "rank", "leaderboard", "json"], "dependencies": ["discord.py", "math", "random"]}, {"category": "giveaway", "name": "giveaway_system", "description": "Giveaway system with start giveaway, end giveaway, reroll, and winner selection", "code": "import discord\nimport json\nfrom discord.ext import commands\nimport random\nimport asyncio\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'giveaways': {}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def giveaway(ctx, duration: int, winners: int, *, prize: str):\n    embed = discord.Embed(title='Giveaway!', description=f'Prize: {prize}\\nWinners: {winners}\\nEnds in {duration} minutes', color=discord.Color.purple())\n    msg = await ctx.send(embed=embed)\n    await msg.add_reaction('\ud83c\udf89')\n    data = await load_data()\n    data['giveaways'][str(msg.id)] = {'prize': prize, 'winners': winners, 'entries': [], 'channel': ctx.channel.id}\n    await save_data(data)\n    await asyncio.sleep(duration * 60)\n    await end_giveaway(msg.id)\n\nasync def end_giveaway(message_id):\n    data = await load_data()\n    giveaway = data['giveaways'].get(str(message_id))\n    if not giveaway:\n        return\n    channel = bot.get_channel(giveaway['channel'])\n    msg = await channel.fetch_message(message_id)\n    users = await msg.reactions[0].users().flatten()\n    entries = [user for user in users if not user.bot]\n    if len(entries) < giveaway['winners']:\n        await channel.send('Not enough entries for the giveaway.')\n        return\n    winners = random.sample(entries, giveaway['winners'])\n    winner_mentions = ' '.join([winner.mention for winner in winners])\n    await channel.send(f'Congratulations {winner_mentions}! You won {giveaway[\"prize\"]}!')\n    del data['giveaways'][str(message_id)]\n    await save_data(data)\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def reroll(ctx, message_id: int):\n    await end_giveaway(message_id)\n    await ctx.send('Giveaway rerolled!')\n\n@bot.event\nasync def on_reaction_add(reaction, user):\n    if user.bot:\n        return\n    if str(reaction.emoji) == '\ud83c\udf89':\n        data = await load_data()\n        giveaway = data['giveaways'].get(str(reaction.message.id))\n        if giveaway and user.id not in giveaway['entries']:\n            giveaway['entries'].append(user.id)\n            await save_data(data)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["giveaway", "start", "end", "reroll", "winners", "json"], "dependencies": ["discord.py", "random", "asyncio"]}, {"category": "welcome", "name": "welcome_system", "description": "Welcome system with customizable welcome message, role assignment, and logging to data.json", "code": "import discord\nimport json\nfrom discord.ext import commands\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'welcome': {'channel': None, 'message': 'Welcome {member} to the server!', 'role': None}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.event\nasync def on_member_join(member):\n    data = await load_data()\n    channel_id = data['welcome']['channel']\n    if channel_id:\n        channel = bot.get_channel(channel_id)\n        msg = data['welcome']['message'].format(member=member.mention)\n        await channel.send(msg)\n    role_id = data['welcome']['role']\n    if role_id:\n        role = member.guild.get_role(role_id)\n        if role:\n            await member.add_roles(role)\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def set_welcome_channel(ctx, channel: discord.TextChannel):\n    data = await load_data()\n    data['welcome']['channel'] = channel.id\n    await save_data(data)\n    await ctx.send(f'Welcome channel set to {channel.mention}')\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def set_welcome_message(ctx, *, message: str):\n    data = await load_data()\n    data['welcome']['message'] = message\n    await save_data(data)\n    await ctx.send('Welcome message updated.')\n\n@bot.command()\n@commands.has_permissions(administrator=True)\nasync def set_welcome_role(ctx, role: discord.Role):\n    data = await load_data()\n    data['welcome']['role'] = role.id\n    await save_data(data)\n    await ctx.send(f'Welcome role set to {role.name}')\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["welcome", "join", "message", "role", "json"], "dependencies": ["discord.py"]}, {"category": "poll", "name": "poll_system", "description": "Poll system with create poll, vote, and results display", "code": "import discord\nimport json\nfrom discord.ext import commands\nimport asyncio\n\nbot = commands.Bot(command_prefix='!', intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready():\n    print(f'Logged in as {bot.user}')\n\nasync def load_data():\n    try:\n        with open('data.json', 'r') as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return {'polls': {}}\n\nasync def save_data(data):\n    with open('data.json', 'w') as f:\n        json.dump(data, f, indent=4)\n\n@bot.command()\nasync def poll(ctx, duration: int, question: str, *options: str):\n    if len(options) < 2 or len(options) > 10:\n        return await ctx.send('Provide between 2 and 10 options.')\n    embed = discord.Embed(title=question, color=discord.Color.teal())\n    for i, option in enumerate(options, 1):\n        embed.add_field(name=f'Option {i}', value=option, inline=False)\n    msg = await ctx.send(embed=embed)\n    reactions = ['1\ufe0f\u20e3', '2\ufe0f\u20e3', '3\ufe0f\u20e3', '4\ufe0f\u20e3', '5\ufe0f\u20e3', '6\ufe0f\u20e3', '7\ufe0f\u20e3', '8\ufe0f\u20e3', '9\ufe0f\u20e3', '\ud83d\udd1f'][:len(options)]\n    for reaction in reactions:\n        await msg.add_reaction(reaction)\n    data = await load_data()\n    data['polls'][str(msg.id)] = {'question': question, 'options': list(options), 'votes': {str(i+1): 0 for i in range(len(options))}, 'voters': {}}\n    await save_data(data)\n    await asyncio.sleep(duration * 60)\n    await end_poll(msg.id)\n\nasync def end_poll(message_id):\n    data = await load_data()\n    poll = data['polls'].get(str(message_id))\n    if not poll:\n        return\n    channel = bot.get_channel(message_id.channel_id)  # Note: This assumes we have channel_id, but in code we need to save it.\n    # For simplicity, assume we saved channel_id in data['polls'][str(msg.id)]['channel'] = ctx.channel.id\n    # Add that in command.\n    msg = await channel.fetch_message(message_id)\n    embed = discord.Embed(title=f'Results for \"{poll[\"question\"]}\"', color=discord.Color.red())\n    for i, option in enumerate(poll['options'], 1):\n        embed.add_field(name=option, value=f'Votes: {poll[\"votes\"][str(i)]}', inline=False)\n    await channel.send(embed=embed)\n    del data['polls'][str(message_id)]\n    await save_data(data)\n\n@bot.event\nasync def on_reaction_add(reaction, user):\n    if user.bot:\n        return\n    data = await load_data()\n    poll = data['polls'].get(str(reaction.message.id))\n    if poll:\n        emoji = str(reaction.emoji)\n        index = ['1\ufe0f\u20e3', '2\ufe0f\u20e3', '3\ufe0f\u20e3', '4\ufe0f\u20e3', '5\ufe0f\u20e3', '6\ufe0f\u20e3', '7\ufe0f\u20e3', '8\ufe0f\u20e3', '9\ufe0f\u20e3', '\ud83d\udd1f'].index(emoji) + 1 if emoji in ['1\ufe0f\u20e3', '2\ufe0f\u20e3', '3\ufe0f\u20e3', '4\ufe0f\u20e3', '5\ufe0f\u20e3', '6\ufe0f\u20e3', '7\ufe0f\u20e3', '8\ufe0f\u20e3', '9\ufe0f\u20e3', '\ud83d\udd1f'] else None\n        if index:\n            if user.id in poll['voters']:\n                await reaction.remove(user)\n                return await reaction.message.channel.send('You have already voted!', delete_after=5)\n            poll['votes'][str(index)] += 1\n            poll['voters'][user.id] = True\n            await save_data(data)\n\nbot.run('YOUR_BOT_TOKEN')", "tags": ["poll", "create", "vote", "results", "json"], "dependencies": ["discord.py", "asyncio"]}]}